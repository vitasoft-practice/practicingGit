"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeAll = exports.removeVersions = void 0;
const bvm_list_1 = require("@teambit/bvm.list");
const bvm_config_1 = require("@teambit/bvm.config");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_intersection_1 = __importDefault(require("lodash.intersection"));
const lodash_difference_1 = __importDefault(require("lodash.difference"));
const path_1 = __importDefault(require("path"));
const semver_sort_1 = require("semver-sort");
const config = bvm_config_1.Config.load();
function removeVersions(versions) {
    return __awaiter(this, void 0, void 0, function* () {
        let resolvedVersions = versions;
        const localVersions = yield bvm_list_1.listLocal();
        if (versions.includes('latest')) {
            const latestVersion = (yield bvm_list_1.listLocal()).latest().version;
            resolvedVersions = resolvedVersions.filter(version => {
                return (version !== 'latest');
            });
            resolvedVersions.push(latestVersion);
        }
        const missingVersions = lodash_difference_1.default(resolvedVersions, localVersions.toVersionsStringArray());
        const removedVersions = lodash_intersection_1.default(resolvedVersions, localVersions.toVersionsStringArray());
        if (!removeVersions.length) {
            return {
                missingVersions,
                removedVersions
            };
        }
        const allVersionsDir = config.getBitVersionsDir();
        const promises = removedVersions.map(version => {
            const versionPath = path_1.default.join(allVersionsDir, version);
            return fs_extra_1.default.remove(versionPath);
        });
        yield Promise.all(promises);
        return {
            missingVersions,
            removedVersions
        };
    });
}
exports.removeVersions = removeVersions;
function removeAll(versionsToKeep = [], numberOfLatestToKeep = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        const localVersions = yield bvm_list_1.listLocal();
        const withoutVersionsToKeep = lodash_difference_1.default(localVersions.toVersionsStringArray(), versionsToKeep);
        let versionsToRemove = withoutVersionsToKeep;
        if (numberOfLatestToKeep > 0) {
            versionsToRemove = semver_sort_1.desc(versionsToRemove);
            versionsToRemove.splice(0, numberOfLatestToKeep);
        }
        return this.removeVersions(versionsToRemove);
    });
}
exports.removeAll = removeAll;
//# sourceMappingURL=remove.js.map